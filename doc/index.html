<!doctype html>
<html lang="en">
  <!-- the file is written by hand, with emacs and love -->
  <head>
    <meta charset="utf-8">
    <meta name="description"    content="MIDA Manual">
    <meta name="author"         content="Mark Karpov">
    <meta name="dcterms.rights" content="(c) 2014 Mark Karpov">
    <meta name="keywords"       content="generative music, midi">
    <title>MIDA Manual</title>
    <link href="mida.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <h1 id="top">MIDA</h1>
    <h2>Table of Contents</h2>
    <ul>
      <li><a href="#1">1 What is MIDA?</a></li>
      <li><a href="#2">2 Installation</a>
        <ul>
          <li><a href="#2.1">2.1 Windows</a></li>
          <li><a href="#2.2">2.2 Linux</a></li>
          <li><a href="#2.3">2.3 Compilation from Source</a></li>
      </ul></li>
      <li><a href="#3">3 Invocation</a></li>
      <li><a href="#4">4 Configuration File</a></li>
      <li><a href="#5">5 MIDA Tutorial</a>
        <ul>
          <li><a href="#5.1">5.1 Literals</a>
            <ul>
              <li><a href="#5.1.1">5.1.1 Durations</a></li>
              <li><a href="#5.1.2">5.1.2 Velocities</a></li>
              <li><a href="#5.1.3">5.1.3 Pitch</a></li>
          </ul></li>
          <li><a href="#5.2">5.2 Elements</a></li>
          <li><a href="#5.3">5.3 Principles and Realizations</a></li>
          <li><a href="#5.4">5.4 Definitions</a></li>
          <li><a href="#5.5">5.5 Special Commands and Workflow</a></li>
          <li><a href="#5.6">5.6 Ranges</a></li>
          <li><a href="#5.7">5.7 Addition</a></li>
          <li><a href="#5.8">5.8 Multiplication</a></li>
          <li><a href="#5.9">5.9 Repitition</a></li>
          <li><a href="#5.10">5.10 Rotation</a></li>
          <li><a href="#5.11">5.11 Multivalues</a></li>
          <li><a href="#5.12">5.12 Conditional Multivalues</a></li>
      </ul></li>
      <li><a href="#6">6 Final Notes</a></li>
    </ul>
    <h2 id="1">1 What is MIFE?</h2>
    <p> MIFE stands for 'Materialistic Interactive Fiction
    Engine'. This software was developed to be a free tool for
    everyone, who is interested in playing or / and creation of
    materialistic interactive fiction games. The definition of
    materialistic IF is given in <a href="#2">section 2.</a></p>
    <p> Manual Copyright &copy; 2014 Mark Karpov.</p>
    <p> MIFE Copyright &copy; 2014 Mark Karpov.</p>
    <p> All contents here is copyright by the developer and is
    released under the <a href =
    "http://www.gnu.org/copyleft/fdl.html"> GNU Free Documentation
    License</a>.</p>
    <p> MIFE is licensed under <a href =
    "http://www.gnu.org/copyleft/gpl.html">GNU General Public
    License</a>; it's opensource, free software.</p>
    <p><a href="#top">back to the top</a></p>
    <h2 id="2">2 Materialistic Concept of IF</h2>
    <p> To put it simply, materialistic IF (MIF) implies higher level
    of interactivity, freedom, and playing in open world without rigid
    scenario.</p>
    <p> Aim of MIF is not leading player through 'nodes' of a story,
    but rather letting him/her do what he/she wants and
    just <i>render</i> it in text. As a result of the design, a MIF
    game is about items. Not just things that we can take and drop,
    but about all sorts of things that appear in game, but they have
    to be <i>material</i>.</p>
    <p> Usually, not every item in IF game can be interacted
    with. Some items exist only as a part of storytelling and you have
    to guess which is useful and which is not. Not so in MIF: every
    item, that you encounter in text, is a real, separate object. Try
    everything. Everything is possible, or almost everything.</p>
    <p> Game world in MIF game is usually quite independent of
    player. One simple way to introduce the independency is
    time. Everything is living. There may not exist fixed plan of
    actions to win. There may be no way to 'win' at all.</p>
    <p> MIF games need uber-level parser. MIFE has one. Feel naturally
    with it. Just tell it what you want to do in imperative mood,
    that's all. Forget about 'i' as 'inventory', 'n' as 'north',
    etc. 'I' is a pronoun. In real life one doesn't usually know where
    is north. Wanna say 'go there' if there is only one option? Just
    type it. If game says 'here are ten trolls', just type 'grab
    sword, then kill five of them with it!'. Works. MIFE parser can
    even correct misspellings.</p>
    <p> Since the MIF games are getting far from literature, they're
    flexible enough to use not only parser, but also
    text-synthesis. The same way you can upgrade textures of a visual
    game, you can change style of text in MIF game. Think about it
    again: contents of world and the way you perceive them are
    different things!</p>
    <p> Can text game be interesting nowadays? Yes. Text is unique
    medium for this sort of games, as you start to use your
    imagination more than you do when playing visual games. Another
    reason to give it a try is the fact that you never know limits of
    what you can do in such a game. Think about visual games again
    &ndash; after a while you eventually know all possibilities, but
    in a MIF game there is always something to explore.</p>
    <p><a href="#top">back to the top</a></p>
    <h2 id="3">3 Using MIFE</h2>
    <p> One can use MIFE to play and create MIF games. It is
    simple.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="3.1">3.1 Requirements</h3>
    <p> MIFE needs preinstalled <a href =
    "http://www.clisp.org/">CLISP</a> implementation of ANSI Common
    Lisp to work. This is free software that published under <a href =
    "http://www.gnu.org/copyleft/gpl.html">GNU General Public
    License</a>.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="3.2">3.2 Installation</h3>
    <p> Currently supported platforms
    are <a href="http://en.wikipedia.org/wiki/Microsoft_Windows">MS
    Windows</a>
    and <a href="http://en.wikipedia.org/wiki/Linux">Linux</a>.</p>
    <h4 id="3.2.1">3.2.1 Windows</h4>
    <p> First, download and install <a href =
    "http://www.clisp.org/">CLISP</a>. Then download <a href =
    "https://github.com/mrkkrp/mife/releases">MIFE installer for MS
    Windows</a>. Run it and install MIFE. That's it.</p>
    <h4 id="3.2.2">3.2.2 Linux</h4>
    <p> Install CLISP using your package manager. MIFE for Linux is
    distributing as self-extracting shell script (<a href =
    "https://github.com/mrkkrp/mife/releases">get it on GitHub</a>). I
    have not created package for it, because I have no time to
    maintain such a package for whole variety of linux package
    systems.</p>
    <p> But the situation may change. Check your repositories if they
    contain MIFE. If there is no MIFE release for your Linux
    distribution, you always can install MIFE via self-extracting
    shell script.</p>
    <p> You should run the script as root or with <code>sudo</code>,
    then start MIFE as normal user and it will create
    directory <code>~/mife/</code> with all necessary stuff (default
    games, directory for saves, configuration file, and your copy of
    dictionary).</p>
    <h4 id="3.2.3">3.2.3 Compilation from Source</h4>
    <p> In order to compile MIFE you'll need installed CLISP,
    <a href="http://common-lisp.net/project/asdf/">ASDF</a> (3.1+) and
    library <a href="http://common-lisp.net/project/cl-store/">CL-STORE</a>.
    Probably, the best way to install all the stuff is with
    <a href="http://www.quicklisp.org/beta/">Quicklisp</a>. Quicklisp
    will automatically install ASDF (although it currently supplies
    version 2.26, so you'll have to download fresh ASDF version and
    move it into quicklisp folder) and you will need to execute only
    one command to download CL-STORE:</p>
    <pre>(ql:quickload "cl-store")</pre>
    <p>Here is step-by-step instructions:</p>
    <p>1. Install CLISP;</p>
    <p>2. Install ASDF 3.1+;</p>
    <p>3. Install CL-STORE;</p>
    <p>4. Download and untar git repository of MIFE, or clone it:</p>
    <pre>$ git clone https://github.com/mrkkrp/mife.git master</pre>
    <p>Go to the root directory of the repository and execute:</p>
    <pre>$ sh make.sh</pre>
    <p>To install the program execute:</p>
    <pre># sh install.sh</pre>
    <p>Done.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="3.3">3.3 Invocation</h3>
    <p> At the time of the writing, only console version of the engine
    existed in form of shell script. It is possible to write a visual
    shell with GUI for any platform, since MIFE supports socket mode
    of I/O.</p>
    <p>Here are invocation parameters:</p>
    <pre>$ mife { *.lisp | *.mifg } [ port ] [ host ]</pre>
    <p> If the first parameter is <code>*.lisp</code> file, it will be
    compiled to <code>*.mifg</code> game. A new file will be created
    with the same name as your source file and extension
    <code>mifg</code>.</p>
    <p> If the first parameter is <code>*.mifg</code> file, it will be
    loaded into engine and game will begin.</p>
    <p> Optional <code>port</code> parameter will cause redirection of
    I/O streams; socket stream on specified port will be used.</p>
    <p> <code>host</code> parameter specifies IP of server application
    for socket interaction. If this parameter is not supplied, value
    <code>127.0.0.1</code> will be used.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="3.4">3.4 Engine Commands</h3>
    <p> MIFE supports set of commands for management. One may enter
    them while in game loop. These commands begin with
    asterisk <code>*</code>. You can always get full list of supported
    commands and their meaning with <code>*HELP</code> command.</p>
    <p> Basic list of commands is shown below. All the commands are
    case-insensitive.</p>
    <table>
      <tr><th>Command</th><th>Description</th></tr>
      <tr><td><code>*help</code></td><td>Prints complete information regarding engine commands</td></tr>
      <tr><td><code>*load</code></td><td>Loads a game from file</td></tr>
      <tr><td><code>*quit</code></td><td>Terminates current engine session</td></tr>
      <tr><td><code>*save</code></td><td>Saves current game in a file</td></tr>
    </table>
    <p> These commands are sufficient for gaming, but if you want to
    develop games with MIFE, you probably will need more
    commands. Read on, and I'll show you how to add your own. </p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="3.5">3.5 Customization</h3>
    <p> MIFE evolved into a very flexible tool. One can configure MIFE
    by editing dictionary file and configuration file. </p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="3.5.1">3.5.1 Dictionary</h4>
    <p> MIFE dictionary includes two levels of items: </p>
      <ul>
        <li><b>&bull; common dictionary</b> (loaded from file);</li>
        <li><b>&bull; game-specific words</b> (defined in source code
        of a game).</li>
      </ul>
    <p> Common dictionary can be found in <code>text/dict.txt</code>
    (Linux: <code>~/mife/text/dict.txt</code>). It contains two kinds
    of data: words which help parser and sentence patterns. You are
    welcomed to modify everything, but do it wisely.</p>
    <p> <code>dict.txt</code> is read line by line. If a line begins
    with colon <code>:</code>, then a word will be treated as a
    section name. When a line begins with vertical bar <code>|</code>,
    rest of the line will be considered as a comment. If you want to
    add new sections, please consider <a href="#5.3.18">section
    5.3.18</a>; for information about using new dictionary sections
    see <a href="#5.3.6">section 5.3.6</a>.</p>
    <p> Sentence pattens use <a href =
    "http://www.gigamonkeys.com/book/a-few-format-recipes.html">Common
    Lisp Format</a> syntax. When needed, sentence pattens are chosen
    randomly by the engine from all available options.</p>
    <p> Since version 0.2.0, MIFE allows manual control over
    dictionary tributaries. The table below provides information about
    control words which must be placed at the beginning of line.</p>
    <table>
      <tr><th>Control Word</th><th>Meaning</th></tr>
      <tr><td><code>>tributaries-on</code></td><td>Turns on tributaries creation</td></tr>
      <tr><td><code>>tributaries-off</code></td><td>Truns off trubutaries creation</td></tr>
    </table>
    <p> These control words were invented to eliminate impact of
    output patterns on parsing. Tributaries should be on for sections
    that describe input words (related to parsing), they should be off
    for output patterns and words.</p>
    <p> Note that the control words are case-insensitive.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="3.5.2">3.5.2 Configuration File</h4>
    <p> MIFE configuration file is intended to provide level of
    flexibility that inspired by such software
    as <a href="http://www.gnu.org/software/emacs/">Emacs</a>.</p>
    <p> Configuration file <code>.mife</code> can be found in
    installation folder (Windows) or <code>~/mife/.mife</code>
    (Linux). It contains just Common Lisp instructions and gets loaded
    after the engine itself and before loading of dictionary and
    target game.</p>
    <p> Unlike many configuration files, <code>.mife</code> must
    exist, because there is no default values for variables that set
    there. This way, user can see comprehensive collection of
    parameters and just correct values that are interesting.</p>
    <p> Let us take a look at all sections of the configuration
    file.</p>
    <p><a href="#top">back to the top</a></p>
    <h5 id="3.5.2.1">3.5.2.1 Parameters</h5>
    <p> A lot of variables are set in the configuration file. They are
    set by <code>setf</code> macro. It processes values in this
    manner: it takes one and treats it as name of a variable, then it
    takes next one and considers it as the variable's value. The
    process goes on and on, untill all arguments are processed.</p>
    <p> Here is table that describles all default variables.</p>
    <table>
      <tr><th style="width: 175px">Variable</th><th>Description</th></tr>
      <tr><td><code>*io-stream*</code></td>
        <td>Default stream for input-output operations; changing not
        recommended.</td></tr>
      <tr><td><code>*trim-chars*</code></td>
        <td>Characters that get trimmed from beginning and end of any
        user's input.</td></tr>
      <tr><td><code>*input-filter*</code></td>
        <td>String consisting of all characters that will be deleted
        from any user's input.</td></tr>
      <tr><td><code>*engine-cmd-prefix*</code></td>
        <td>Engine command prefix. Input that begins with this string
        will be treated as engine command.</td></tr>
      <tr><td><code>*line-length*</code></td>
        <td>Total maximal width (in symbols) of output.</td></tr>
      <tr><td><code>*output-margins*</code></td>
        <td>Collection of margins for different styles of output. You
        can remove all margins by using <code>nil</code>.</td></tr>
      <tr><td><code>*output-patterns*</code></td>
        <td>Collection of patterns that get applied to output. You can
        add new ones, or remove all the patterns by
        using <code>nil</code>.</td></tr>
      <tr><td><code>*output-colours*</code></td>
        <td>Collection of colours for different output styles. See
        table below for information about colour-coding.</td></tr>
      <tr><td><code>*input-prompt*</code></td>
        <td>Prompt that will be displayed before every user's input.</td></tr>
      <tr><td><code>*input-colour*</code></td>
        <td>User's input will be colorized with this colour.</td></tr>
      <tr><td><code>*use-colours*</code></td>
        <td>If the value is non-<code>nil</code>, colorized terminal
        output will be used.</td></tr>
      <tr><td><code>*months*</code></td><td>Array of month names.</td></tr>
      <tr><td><code>*days*</code></td><td>Array of day names. </td></tr>
      <tr><td><code>*time-pattern*</code></td><td>Pattern for
        rendering time as string. Used by
        function <code>time-get</code>.</td></tr>
      <tr><td><code>*words-delimiter*</code></td>
        <td>This character is used by parser to split words.</td></tr>
      <tr><td><code>*phrase-delimiter*</code></td>
        <td>This character is used by parser to split phrases.</td></tr>
      <tr><td><code>*plural-designator*</code></td>
        <td>This character is used to recognize which words have to be
        altered during generation of plural forms.</td></tr>
      <tr><td><code>*apostrophe*</code></td>
        <td>Well, normally it's apostrophe <code>'</code>.</td></tr>
      <tr><td><code>*bexpansion-begin*</code></td>
        <td>This character is used by parser to find beginning of brace expansion.</td></tr>
      <tr><td><code>*bexpansion-end*</code></td>
        <td>This character is used by parser to find end of brace expansion.</td></tr>
      <tr><td><code>*bexpansion-del*</code></td>
        <td>This character is used by parser as delimiter between brace expansion options.</td></tr>
      <tr><td><code>*critical-distance*</code></td>
        <td>
        If<a href="http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">
        Damerau-Levenshtein distance</a> between input word and its
        properly spelled variant greater than this value, it will not
        be corrected nor recognized.</td></tr>
      <tr><td><code>*default-numeral*</code></td>
        <td> This value is used as acutal numeral for nouns if no
        explicit numeral is mentioned and the noun is in singular
        form.</td></tr>
      <tr><td><code>*chapter-pattern-b*</code></td>
        <td>Basic pattern for printing title of chapter.</td></tr>
      <tr><td><code>*chapter-pattern-n*</code></td>
        <td>This pattern is used to print number of chapter and its title.</td></tr>
      <tr><td><code>*countable-limit*</code></td>
        <td>If quantity of something in game is greater than this
        number, it will be displayed using uncertain terms.</td></tr>
      <tr><td><code>*invisible-pos*</code></td>
        <td>This value is used to recognize invisible slots in
        containers.</td></tr>
      <tr><td><code>*save-ext*</code></td>
        <td>Extension of saved game file.</td></tr>
      <tr><td><code>*game-ext*</code></td>
        <td>Extension of MIFE game byte-code.</td></tr>
      <tr><td><code>*source-ext*</code></td>
        <td>Extension of source file.</td></tr>
      <tr><td><code>*dict-comment-char*</code></td>
        <td>Rest of line in dictionary after this character is
        considered as a comment.</td></tr>
      <tr><td><code>*dict-section-char*</code></td>
        <td>Names of sections in dictionary begin with this character.</td></tr>
      <tr><td><code>*dict-trib-on*</code></td>
        <td>Dictionary command that enables tributaries.</td></tr>
      <tr><td><code>*dict-trib-off*</code></td>
        <td>Dictionary command that disables tributaries.</td></tr>
    </table>
    <p> And here is colour-code table:</p>
    <table>
      <tr><th style="border-top: 0px; border-left: 0px"></th>
        <th>Black</th><th>Red</th><th>Green</th><th>Yellow</th>
        <th>Blue</th><th>Magenta</th><th>Cyan</th><th>White</th></tr>
      <tr><th>Normal</th><td><code>0</code></td><td><code>1</code></td>
        <td><code>2</code></td><td><code>3</code></td><td><code>4</code></td>
        <td><code>5</code></td><td><code>6</code></td><td><code>7</code></td>
      </tr>
      <tr><th>Bright</th><td><code>8</code></td><td><code>9</code></td>
        <td><code>10</code></td><td><code>11</code></td><td><code>12</code></td>
        <td><code>13</code></td><td><code>14</code></td><td><code>15</code></td>
      </tr>
    </table>
    <p> Currently MIFE supports only changing of foreground colour.</p>
    <p><a href="#top">back to the top</a></p>
    <h5 id="3.5.2.2">3.5.2.2 Hooks</h5>
    <p> MIFE allows user to define arbitrary actions that will be
    undertaken on some predefined event. This mechanism is called
    'hook'. One can define any number of hooks for one event with
    function <code>add-hook</code>. Syntax of the function is
    described below.</p>
    <h6>Syntax</h6>
    <pre>add-hook event fnc</pre>
    <h6>Arguments</h6>
    <p><code>event</code> &ndash; a keyword.</p>
    <p><code>fnc</code> &ndash; a function.</p>
    <h6>Description</h6>
    <p><code>add-hook</code> creates new hook that will call
    function <code>fnc</code> on event wich defined by
    value <code>event</code> (see full list below). Supplied function
    must be able to take all parameters that are idiomatic for
    specified event.</p>
    <h6>Events</h6>
    <p> Full list of events and corresponding arguments are given below.</p>
    <table>
      <tr><th style="width: 175px">Event</th><th>Arguments</th><th>Performed</th></tr>
      <tr><td><code>:on-after-chapter</code></td>
        <td><code>index</code> &ndash; an integer or symbol, ID of chapter</td>
        <td>after printing of chapter title</td></tr>
      <tr><td><code>:on-after-compile</code></td>
        <td><code>filename</code> &ndash; pathname to compiled game</td>
        <td>after compilation of a game</td></tr>
      <tr><td><code>:on-after-dict-load</code></td>
        <td style="text-align: center">&ndash;</td>
        <td>after loading of dictionary file</td></tr>
      <tr><td><code>:on-after-final</code></td>
        <td><code>index</code> &ndash; an integer, index of final</td>
        <td>after <a href="#5.3.4">finalization of a game</a></td></tr>
      <tr><td><code>:on-after-intro</code></td>
        <td style="text-align: center">&ndash;</td>
        <td>after printing of game intro</td></tr>
      <tr><td><code>:on-after-load</code></td>
        <td><code>filename</code> &ndash; pathname to loaded game</td>
        <td>after loading of a saved game</td></tr>
      <tr><td><code>:on-after-parse</code></td>
        <td><code>les</code> &ndash; list of lexical elements, result of parsing</td>
        <td>after parsing of user's input</td></tr>
      <tr><td><code>:on-after-save</code></td>
        <td><code>filename</code> &ndash; pathname to saved game</td>
        <td>after saving of game</td></tr>
      <tr><td><code>:on-after-title</code></td>
        <td style="text-align: center">&ndash;</td>
        <td>after printing of game title</td></tr>
      <tr><td><code>:on-analyse</code></td>
        <td><code>word</code> &ndash; string, object of analysis<br>
          <code>previous</code> &ndash; keyword, type of previous word<br>
          <code>parameters</code> &ndash; list of various parameters</td>
        <td>on every step of syntactic analysis</td></tr>
      <tr><td><code>:on-ask</code></td>
        <td><code>result</code> &ndash; string, read input<br>
        <code>cmd</code> &ndash; non-<code>nil</code> value if user
        entered an engine command</td>
        <td>on call of
        function <a href="#5.3.2"><code>ask</code></a></td></tr>
      <tr><td><code>:on-before-chapter</code></td>
        <td><code>index</code> &ndash; an integer or symbol, ID of chapter</td>
        <td>before printing of chapter title</td></tr>
      <tr><td><code>:on-before-compile</code></td>
        <td><code>filename</code> &ndash; pathname to source file</td>
        <td>before compilation of a game</td></tr>
      <tr><td><code>:on-before-dict-load</code></td>
        <td style="text-align: center">&ndash;</td>
        <td>before loading of dictionary file</td></tr>
      <tr><td><code>:on-before-final</code></td>
        <td><code>index</code> &ndash; an integer, index of actual final</td>
        <td> before finalization of a game</td></tr>
      <tr><td><code>:on-before-intro</code></td>
        <td style="text-align: center">&ndash;</td>
        <td> before printing of game intro</td></tr>
      <tr><td><code>:on-before-load</code></td>
        <td style="text-align: center">&ndash;</td>
        <td> before loading of a saved game</td></tr>
      <tr><td><code>:on-before-parse</code></td>
        <td><code>str</code> &ndash; string, argument of parser</td>
        <td>perforemed before parsing</td></tr>
      <tr><td><code>:on-before-save</code></td>
        <td style="text-align: center">&ndash;</td>
        <td> before save game dialog</td></tr>
      <tr><td><code>:on-before-title</code></td>
        <td style="text-align: center">&ndash;</td>
        <td> before printing of game title</td></tr>
      <tr><td><code>:on-cmn</code></td>
        <td><code>name</code> &ndash; a keyword, name of common lump</td>
        <td> when engine processes definition
        of <a href="#5.4">common lump</a></td></tr>
      <tr><td><code>:on-context-add</code></td>
        <td><code>symbols</code> &ndash; list of symbols (IDs)</td>
        <td> when IDs are inserted into context</td></tr>
      <tr><td><code>:on-context-rem</code></td>
        <td><code>symbols</code> &ndash; list of symbols (IDs)</td>
        <td> when IDs are removed from context</td></tr>
      <tr><td><code>:on-correct</code></td>
        <td><code>input</code> &ndash; a string, original word<br>
        <code>output</code> &ndash; a string or <code>nil</code>, result of correction</td>
        <td> on correction of every word of user's input</td></tr>
      <tr><td><code>:on-create</code></td>
        <td><code>place-id</code> &ndash; a symbol, ID of target place<br>
          <code>rest</code> &ndash; list of supplied parameters</td>
        <td> on call of
        function <a href="#5.3.12"><code>create</code></a></td></tr>
      <tr><td><code>:on-create*</code></td>
        <td><code>rest</code> &ndash; list of supplied parameters</td>
        <td> on call of
        function <a href="#5.3.12"><code>create*</code></a></td></tr>
      <tr><td><code>:on-destroy</code></td>
        <td><code>place-id</code> &ndash; a symbol, ID of target place<br>
          <code>rest</code> &ndash; list of supplied parameters</td>
        <td> on call of
        function <a href="#5.3.13"><code>destroy</code></a></td></tr>
      <tr><td><code>:on-destroy*</code></td>
        <td><code>rest</code> &ndash; list of supplied parameters</td>
        <td> on call of
        function <a href="#5.3.13"><code>destroy*</code></a></td></tr>
      <tr><td><code>:on-dict-add</code></td>
        <td><code>section</code> &ndash; a keyword, section name<br>
        <code>word</code> &ndash; a string, actual word</td>
        <td> when a word is inserted into dictionary</td></tr>
      <tr><td><code>:on-dict-check</code></td>
        <td><code>section</code> &ndash; a keyword, section name<br>
        <code>word</code> &ndash; a string, actual word<br>
        <code>result</code> &ndash; non-<code>nil</code> value
        if <code>word</code> is present in <code>section</code></td>
        <td> on call of function <code>dict-check</code></td></tr>
      <tr><td><code>:on-dict-trib-switch</code></td>
        <td><code>old</code> &ndash; boolean, old status<br>
        <code>new</code> &ndash; boolean, new status</td>
        <td> on switching of tributaries (on / off)</td></tr>
      <tr><td><code>:on-drop</code></td>
        <td><code>id</code> &ndash; a symbol, ID of actual item<br>
        <code>quantity</code> &ndash; an integer, quantity</td>
        <td> on call of
        function <a href="#5.3.17"><code>drop</code></a></td></tr>
      <tr><td><code>:on-engine-quit</code></td>
        <td><code>path</code> &ndash; pathname to working directory<br>
        <code>filename</code> &ndash; pathname to source or compiled game<br>
        <code>port</code> &ndash; port for socket interaction or <code>nil</code><br>
        <code>host</code> &ndash; IP of server application for socket interaction</td>
        <td> on quit</td></tr>
      <tr><td><code>:on-engine-start</code></td>
        <td><code>path</code> &ndash; pathname to working directory<br>
        <code>filename</code> &ndash; pathname to source or compiled game<br>
        <code>port</code> &ndash; port for socket interaction or <code>nil</code><br>
        <code>host</code> &ndash; IP of server application for socket interaction</td>
        <td> on start of engine</td></tr>
      <tr><td><code>:on-instance</code></td>
        <td><code>id</code> &ndash; a symbol, ID of new object<br>
        <code>type</code> &ndash; a sybmol, type of new object</td>
        <td> on initialization of a new object</td></tr>
      <tr><td><code>:on-int</code></td>
        <td><code>type</code> &ndash; a symbol, first parameter
        of <code>int</code> form</td>
        <td> on call of <code>int</code> function</td></tr>
      <tr><td><code>:on-inventory</code></td>
        <td style="text-align: center">&ndash;</td>
        <td> on call of
        function <a href="#5.3.11"><code>player-inventory</code></a></td></tr>
      <tr><td><code>:on-live</code></td>
        <td><code>id</code> &ndash; a symbol, ID of actual object</td>
        <td> for every processed <a href="#5.1.2.5">event</a></td></tr>
      <tr><td><code>:on-look</code></td>
        <td><code>id</code> &ndash; a symbol, ID of current location</td>
        <td> on call of
        function <a href="#5.3.8"><code>look-around</code></a></td></tr>
      <tr><td><code>:on-name</code></td>
        <td><code>id</code> &ndash; a symbol, ID of object<br>
        <code>quantity</code> &ndash; an integer, quantity<br>
        <code>result</code> &ndash; a string, result</td>
        <td> on call of
        function <a href="#5.3.5"><code>use-name</code></a></td></tr>
      <tr><td><code>:on-new</code></td>
        <td><code>type</code> &ndash; a symbol, name of new type</td>
        <td> on defining of new MIFE classes</td></tr>
      <tr><td><code>:on-perform</code></td>
        <td><code>id</code> &ndash; a symbol, id of actual object<br>
        <code>le</code> &ndash; lexical element</td>
        <td> on every interaction between player and an
        object</td></tr>
      <tr><td><code>:on-pick-up</code></td>
        <td><code>id</code> &ndash; a symbol, ID of actual item<br>
        <code>quantity</code> &ndash; an integer, quantity</td>
        <td> on call of
        function <a href="#5.3.16"><code>pick-up</code></a></td></tr>
      <tr><td><code>:on-say</code></td>
        <td><code>style</code> &ndash; a keyword, printing style<br>
        <code>str</code> &ndash; result string</td>
        <td> on call of
        function <a href="#5.3.2"><code>say</code></a></td></tr>
      <tr><td><code>:on-script</code></td>
        <td><code>script</code> &ndash; actual script<br>
        <code>id</code> &ndash; a symbol, ID of actual object</td>
        <td> everytime when a script is played</td></tr>
      <tr><td><code>:on-storable-slot</code></td>
        <td><code>symbol</code> &ndash; a symbol, name of new storable slot</td>
        <td> on adding of storable slots</td></tr>
      <tr><td><code>:on-time-add</code></td>
        <td><code>sec</code> &ndash; an integer, number of seconds</td>
        <td> on every incrementation of in-game time</td></tr>
      <tr><td><code>:on-travel</code></td>
        <td><code>place-id</code> &ndash; a symbol, ID of destination</td>
        <td> on every call of
        function <a href="#5.3.9"><code>travel-to</code></a></td></tr>
    </table>
    <p><a href="#top">back to the top</a></p>
    <h5 id="3.5.2.3">3.5.2.3 Engine Commands</h5>
    <p> One can easily add new engine commands or even modify existing
    ones. To do so, use function <code>add-engine-cmd</code>, its
    syntax is shown below.</p>
    <h6>Syntax</h6>
    <pre> add-engine-cmd cmd fnc doc</pre>
    <h6>Arguments</h6>
    <p><code>cmd, doc</code> &ndash; strings.</p>
    <p><code>fnc</code> &ndash; a function.</p>
    <h6>Description</h6>
    <p><code>add-engine-cmd</code> adds new engine commands to list of
    available commands. <code>cmd</code> specifies name of the
    command, <code>fnc</code> must be function of zero arguments, it
    will be called for the command processing. <code>doc</code> is a
    documentation string, it will be displayed as part
    of <code>*help</code> command output.</p>
    <p><a href="#top">back to the top</a></p>
    <h5 id="3.5.2.4">3.5.2.4 Solutions for Developers</h5>
    <p> Here I post code that you can use in your configuration file
    to enhance powers of MIFE. It's also good example of what's
    possible to do with configuration file and how to do it. However,
    it's not for normal gaming, since most part of the stuff here is
    cheating ;-)</p>
    <h6>Time</h6>
    <p> Let's start with a simple thing: command to display current
    in-game time. Add the following to your configuration file:</p>
    <pre>(add-engine-cmd "time"
                (lambda nil
                  (say* :tech "current in-game time:~&amp;~a;" (time-get :str)))
                "prints current in-game time")</pre>
    <p> Now you should be able to use the <code>*time</code> command:</p>
    <pre>>   *time
|   Current in-game time:
|   7 hours, Monday, first day of January;
>   wait
    You're waiting...
>   *time
|   Current in-game time:
|   7 hours and 51 minutes, Monday, first day of January;</pre>
    <h6>Eval</h6>
    <p> Here is really handy thing for developer: eval. It evaluates
    arbitrary Common Lisp expression within running game! Add the
    following code to your configuration file:</p>
    <pre>(add-engine-cmd "eval"
                (lambda nil
                  (say* :tech "enter Common Lisp expression:")
                  (princ *input-prompt* *io-stream*)
                  (unwind-protect
                       (say* :tech "~{~s~^ ;~&amp;~}"
                             (let ((*package* (find-package :mife-user)))
                               (multiple-value-list (eval (read *io-stream*)))))
                    (clear-input *io-stream*)))
                "evaluates arbitrary Common Lisp expression")</pre>
    <p> Note that expression works as if they are
    in <code>MIFE-USER</code> package:</p>
    <pre>    You are in room A.
    There is room B on the north.
    This location contains five golden coins on the floor.
>   *eval
|   Enter Common Lisp expression:
>   (create (location) 'coin 5)
|   NIL
>   look
    You are within room A.
    There is room B on the north.
    As for contents of this place, they include ten golden coins on
    the floor.</pre>
    <h6>Room</h6>
    <p> This command helps get information about memory usage: </p>
    <pre>(add-engine-cmd "room"
                (lambda nil
                  (say* :tech (with-output-to-string (*standard-output*)
                                (room :default))))
                "prints information regarding memory usage")</pre>
    <p> Let's take a look... </p>
    <pre>>   *room
|   Number of garbage collections:                7
|   Bytes freed by GC:                    5,472,472
|   Time spent in GC:                      0.033333 sec
|   Bytes permanently allocated:            164,640
|   Bytes currently in use:               4,175,072
|   Bytes available until next GC:          838,980</pre>
    <h6>Context Monitoring</h6>
    <p> Let's have a command that will enable / disable context
    monitoring, so we could see it and check something. Also, I will
    show how to define a command for context displaying. First, define
    an auxiliary variable:</p>
    <pre>(defvar *context-monitor* nil) ; disabled by default</pre>
    <p>OK, now add some hooks to see context changes:</p>
    <pre>(add-hook :on-context-add
          (lambda (symbols)
            (when *context-monitor*
              (say* :tech "context insertion:~&amp;~:[&lt;nothing&gt;~;~:*~{~a~^, ~};~]"
                    symbols))))

(add-hook :on-context-rem
          (lambda (symbols)
            (when *context-monitor*
              (say* :tech "context clearing:~&amp;~:[&lt;nothing&gt;~;~:*~{~a~^, ~};~]"
                    symbols))))</pre>
    <p> Now add engine commands:</p>
    <pre>(add-engine-cmd "cntx"
                (lambda nil
                  (say* :tech "game context:~&amp;~:[&lt;empty&gt;~;~:*~{~a~^, ~};~]"
                        (subcontext (constantly t))))
                "prints current game context")

(add-engine-cmd "cmnt"
                (lambda nil
                  (togglef *context-monitor*)
                  (say* :tech "context monitoring ~:[DISABLED~;ENABLED~];"
                        *context-monitor*))
                "enables / disables context monitor")</pre>
    <p> Example of use: </p>
    <pre>    You stand inside of room A.
    There is room B on the north.
    You encounter here five strange coins on the floor.
>   *cntx
|   Game context:
|   ROOM-A, COIN, STD;
>   *cmnt
|   Context monitoring ENABLED;
>   out
    Getting closer to room B...
|   Context clearing:
|   ROOM-A;
|   Context insertion:
|   ROOM-B, COIN;
    You are in room B.
    There is room A on the south.
    Here is nothing, except for two coins flying in the air.
>   *cmnt
|   Context monitoring DISABLED;
>   out
    Traveling back to room A.
    You are in room A.
    There is room B on the north.
    Here is nothing, except for five coins on the floor.</pre>
    <h6>Dictionary Monitoring</h6>
    <p> We can do similar tricks with dictionary. Let's invent a
    command to display information about dictionary contents. We will
    need an auxiliary variable:</p>
    <pre>(defvar *dictionary-sections* nil)</pre>
    <p> Now create a hook: </p>
    <pre>(add-hook :on-dict-add
          (lambda (section word)
            (declare (ignore word))
            (pushnew section *dictionary-sections*)))</pre>
    <p> And the engine command: </p>
    <pre>(add-engine-cmd "dict"
                (lambda nil
                  (flet ((print-row (x y)
                           (say* :tech "~a~30t | ~14d" x y)))
                    (say* :tech "dictionary statistic:")
                    (print-row "Section" "Entries Number")
                    (print-row "T o t a l:"
                               (do ((x *dictionary-sections* (cdr x))
                                    (total 0))
                                   ((null x) total)
                                 (let* ((x (car x))
                                        (n (dict-number x)))
                                 (print-row x n)
                                 (incf total n))))))
                "prints statistical information about dictionary")</pre>
    <p> Here is some info: </p>
    <pre>>   *dict
|   Dictionary statistic:
|   Section                        | Entries Number
|   NOUN                           |              7
|   VERB                           |             25
|   ST-PARSER-FAILED               |              4
|   ST-NON-ITEM                    |              8
|   ST-DROPING-NO                  |              8
|   ST-DROPING-NORMAL              |              8
|   ST-PICKING-UP-NO               |              8
|   ST-PICKING-UP-ALREADY          |              8
|   ST-PICKING-UP-NORMAL           |              8
|   ST-RETURNING-NO                |              4
|   ST-RETURNING                   |              5
|   ST-TRAVELING                   |              4
|   ST-ENUMERATION                 |              1
|   ST-INVENTORY-EMPTY             |              8
|   ST-INVENTORY-CONTENTS          |              8
|   ST-LOCATION-EMPTY              |              8
|   ST-LOCATION-CONTENTS           |              8
|   ST-LOCATION-UNDER              |              2
|   ST-LOCATION-ON                 |              4
|   ST-LOCATION-IN                 |              5
|   IGNORABLE-ENDINGS              |              2
|   NUMERAL-O-MANY                 |              5
|   PLURAL-SPECIALS                |             11
|   NUMERAL-I                      |             37
|   IGNORABLE                      |             58
|   PREPOSITION                    |             69
|   ANAPHOR-V                      |              7
|   EXCLUSION                      |              5
|   ANAPHOR-ONE                    |              1
|   PLURAL                         |              8
|   ANAPHOR-N                      |              8
|   COMMON                         |             15
|   PHRASE                         |             40
|   SINGLE                         |            236
|   DENIED                         |             23
|   T o t a l:                     |            666</pre>
    <p> Huh, lucky number!</p>
    <h6>Spying on parser</h6>
    <p> Parsing is an interesing thing. And sometimes buggy. So I'm
    going to show you how to spy on parser. First, we'll need an
    auxiliary variable:</p>
    <pre>(defvar *parser-monitor* nil) ; disabled by default</pre>
    <p> Now a couple of hooks will do magic: </p>
    <pre>(add-hook :on-correct
          (lambda (old new)
            (when *parser-monitor*
              (say* :tech "correction: ~s -> ~s" old new))))

(add-hook :on-before-parse
          (lambda (str)
            (when *parser-monitor*
              (say* :tech "parser input: ~s" str))))

(add-hook :on-after-parse
          (lambda (les)
            (when *parser-monitor*
              (say* :tech
                    "~:[parser failed to extract lexical elements~;~
                     ~:*extracted lexical elements:~&amp;~{~a~^,~&amp;~}~];"
                    les))))

(add-hook :on-analyse
          (lambda (word previous p)
            (when *parser-monitor*
              (say* :tech ">>> W: ~s, P: ~a" word previous)
              (say* :tech "L-OBJ: ~s, L-ACT: ~s, L-AUX: ~s, P-AUX: ~s"
                    (first p) (second p) (third p) (fourth p))
              (say* :tech "L-NUM: ~s, P-NUM: ~s, A-ONE: ~s, A-ALL: ~s"
                    (fifth p) (sixth p) (seventh p) (eighth p)))))</pre>
    <p> Add switch: </p>
    <pre>(add-engine-cmd "pmnt"
                (lambda nil
                  (togglef *parser-monitor*)
                  (say* :tech "parser monitoring ~:[DISABLED~;ENABLED~];"
                        *parser-monitor*))
                "enables / disables parser monitor")</pre>
    <p> OK, let's try this monstrosity on something..</p>
    <pre>    You stand inside of room A.
    There is room B on the north.
    You can notice five strange coins on the floor.
>   *pmnt
|   Parser monitoring ENABLED;
>   take a coupe of them
|   Parser input: "take a coupe of them"
|   Correction: "take" -> "take"
|   Correction: "a" -> "a"
|   Correction: "coupe" -> "couple"
|   Correction: "of" -> "of"
|   Correction: "them" -> "them"
|   >>> W: "take", P: NOUN
|   L-OBJ: "strange-coin", L-ACT: "room-b", L-AUX: NIL, P-AUX: NIL
|   L-NUM: 5, P-NUM: 5, A-ONE: NIL, A-ALL: NIL
|   >>> W: "a", P: VERB
|   L-OBJ: "strange-coin", L-ACT: "take", L-AUX: NIL, P-AUX: NIL
|   L-NUM: NIL, P-NUM: 5, A-ONE: NIL, A-ALL: NIL
|   >>> W: "couple", P: VERB
|   L-OBJ: "strange-coin", L-ACT: "take", L-AUX: NIL, P-AUX: NIL
|   L-NUM: NIL, P-NUM: 5, A-ONE: NIL, A-ALL: NIL
|   >>> W: "of", P: NUMERAL-W
|   L-OBJ: "strange-coin", L-ACT: "take", L-AUX: NIL, P-AUX: NIL
|   L-NUM: 2, P-NUM: 2, A-ONE: NIL, A-ALL: NIL
|   >>> W: "them", P: NUMERAL-W
|   L-OBJ: "strange-coin", L-ACT: "take", L-AUX: NIL, P-AUX: NIL
|   L-NUM: 2, P-NUM: 2, A-ONE: NIL, A-ALL: NIL
|   Extracted lexical elements:
|   #&lt;LE OBJ: "strange-coin", ACT: "take", AUX: NIL, BUT: NIL, NUM: 2; #x000334B4E5E8&gt;;
|   Parser input: "two old coins"
|   Correction: "two" -> "two"
|   Correction: "old" -> "old"
|   Correction: "coins" -> "coins"
|   >>> W: "two", P: ANAPHOR-N
|   L-OBJ: "strange-coin", L-ACT: "take", L-AUX: NIL, P-AUX: NIL
|   L-NUM: 2, P-NUM: 2, A-ONE: NIL, A-ALL: NIL
|   >>> W: "old-coins", P: NUMERAL-W
|   L-OBJ: "strange-coin", L-ACT: "take", L-AUX: NIL, P-AUX: NIL
|   L-NUM: 2, P-NUM: 2, A-ONE: NIL, A-ALL: NIL
|   Extracted lexical elements:
|   #&lt;LE OBJ: "old-coin", ACT: "take", AUX: NIL, BUT: NIL, NUM: 2; #x000334B8D988&gt;;
    You've got two old coins now.</pre>
    <p> A lot of stuff. Note, that parser is used by engine itself to
    parse some additional stuff, so expect lotsa text.</p>
    <h6>Loading After Compilation</h6>
    <p> Just in case if you want every game to begin immediately after
    its compilation, here is how: </p>
    <pre>(add-hook :on-after-compile
          (lambda (filename)
            (dict-load)
            (load filename)
            (game-loop)))</pre>
    <p><a href="#top">back to the top</a></p>
    <h3 id="3.6">3.6 Uninstallation</h3>
    <h6>Windows</h6>
    <p> Run uninstaller. </p>
    <h6>Linux</h6>
    <p> Execute: </p>
    <pre># mife remove</pre>
    <p> This command will completely remove MIFE installation from
    your system, except for any personal data that was created by the
    engine in home directory for every user who used the program. To
    perform removing of MIFE installation you must be root. </p>
    <h2 id="4">4 How Do I Create a Game?</h2>
    <p> You are welcomed to create games with MIFE. Rest of this
    manual is devoted to game developing. Note, that game development
    with MIFE may seem more difficult compared with other tools. This
    is because MIFE is mighty beast. All the power of <a href =
    "http://www.google.com/search?q=most+powerful+programming+language">most
    powerful programming language</a> Common Lisp is at your
    service. Nothing is simplified here, but anyway it's not too
    hard.</p>
    <p> Let us start with simple things and I promise that you will
    have written a complete game by the time you finish reading of
    this section!</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="4.1">4.1 What is MIFE Technically?</h3>
    <p> MIFE is <a href =
    "http://en.wikipedia.org/wiki/Domain-specific_language">Domain
    Specific Language</a> (DSL) on top of Common Lisp. That is, you
    can think of MIFE as Common Lisp extension. If you're familiar
    with Lisp, you're almost MIFE professional. But even if name Lisp
    says nothing to you &ndash; fear not, most part of work is already
    done for you.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="4.2">4.2 Creating Sample Game</h3>
    <p> Let us create a simple sample game. The syntax doesn't matter
    for now. This is just an example of development cycle and overall
    feeling.</p>
    <p> OK, my favorite test game called 'Testing Rooms'. It has two
    rooms: 'Room A' and 'Room B'. Cool, yeah? There will be some golden
    coins in these rooms, of course. Well... That's all.</p>
    <p>Here is listing of complete MIFE game:</p>
    <pre>;;;
;;; MIFE Game 'Testing Rooms'
;;;

(int :game
     :title "Testing Rooms"
     :intro "Once upon a time..."
     :finals "You're singing and suddenly wake up in your bedroom." ; index 0
     :start-location 'room-a
     :start-items 'coin 2)

(int :object
     :id 'std
     :present t
     :actions*
     "sing" 20 40 (script () (game-final 0))
     "wait" 2000 3600 (script () (say "you're waiting..."))
     "look{,-around}" 60 120 (script () (look-around))
     "inventory" 60 120 (script () (player-inventory))
     "back return" 40 60 (script () (go-back)))

(int :item
     :id 'coin
     :names "{,old-,strange-,gold-,golden-}coin*"
     :description "looks like really old and strange coin."
     :actions
     "take get pick-up grab" 40 60 (script (id n) (pick-up id n))
     "look-at examine" 60 120 (script (description) (say description))
     "drop throw throw-away get-rid" 40 60 (script (id n) (drop id n)))

(int :place
     :id 'room-a
     :names "room-A"
     :description
     "There is room B on the north." (script nil (use-name 'room-b))
     :actions*
     "north room-b out there {,an}other-room" 40 60
     (script nil (travel-to 'room-b))
     :contents 'coin 5 "on the floor")

(int :place
     :id 'room-b
     :names "room-B"
     :description
     "There is room A on the south." (script nil (use-name 'room-a))
     :actions*
     "south room-a out there {,an}other-room" 40 60
     (script nil (travel-to 'room-a))
     :contents 'coin 2 "flying in the air")</pre>
    <p> not that ugly, yeah? Now it's time to compile it.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="4.3">4.3 Compiling Your Games</h3>
    <p> Save the code in file with extension <code>lisp</code>. It is
    recommended to keep all games in subdirectory <code>games</code>
    of your root MIFE directory.</p>
    <p> Assuming that the file is located
    in <code>games/test.lisp</code>, go to root MIFE directory and
    execute:</p>
    <pre>$ mife games/test.lisp</pre>
    <p> You should get a message like this:</p>
    <pre>|   MIFE 0.3.1
|   Copyright (c) 2014 Mark Karpov
|   Compiling MIFE game "test"...
|   Done successfully.</pre>
    <p> Look at your <code>games</code> directory, a new file named
    <code>test.mifg</code> should appear there. This is compiled byte
    code of your game.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="4.4">4.4 Testing</h3>
    <p> From root directory of your MIFE installation execute the
    following:</p>
    <pre>$ mife games/test.mifg</pre>
    <p> Game will begin. Our test game feels like this:</p>
    <pre>|   MIFE 0.3.1
|   Copyright (c) 2014 Mark Karpov
    
    Testing Rooms
    
    Once upon a time...
    Traveling to the room A...
    You are in the room A.
    There is room B on the north.
    You encounter here five golden coins on the floor.
>   take three of them for now
    Three golden coins? It's not enough, grab even more!
>   now take the rest
    OK, taken.
>   go to the room B
    Traveling to the room B...
    You are in the room B.
    There is room A on the south.
    Pair of old coins flying in the air - all contents of this place.
>   grab everything while singing!
    Two coins: taken.
    You're singing and suddenly wake up in your bedroom.
>   *quit</pre>
    <p> You can also create a shell script which contains the same
    commands that you've entered manually. Another solution is
    creating of a shortcut.</p>
    <p><a href="#top">back to the top</a></p>
    <h2 id="5">5 MIFE Language Reference</h2>
    <p> Now, when you have tried something with MIFE, we're gonig to
    investigate the topic in depth. MIFE basically uses <a href =
    "http://www.gigamonkeys.com/book/syntax-and-semantics.html">Common
    Lisp syntax</a>, so it's worth learning.</p>
    <p> MIFE uses two forms: <code>int</code>
    and <code>new</code>. Inside of <code>int</code> you will often
    use <code>script</code> form. These three forms are sufficient for
    almost everything.</p>
    <p> Since version 0.2.0, MIFE allows using of 'common lumps'. They
    can be declared with
    form <code>cmn</code>. See <a href="#5.4">section 5.4</a> for
    detailed information.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="5.1">5.1 Defining Objects in Game</h3>
    <p> One can define, or introduce objects into a game
    with <code>int</code> form.</p>
    <p> Syntax of <code>int</code> form is (loosely) shown below. </p>
    <pre>int type &amp;key ...</pre>
    <p> The first element after <code>int</code> specifies type of new
    object. Next, you can put some <i>key parameters</i>. Exact list
    of these parameters depends on given type.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.1.1">5.1.1 Introduce Game</h4>
    <p> The first thing to introduce is game itself. To do so, you
    should put symbol <code>:game</code> as the first parameter
    of <code>int</code> form. Complete syntax is given below.</p>
    <h6>Syntax</h6>
    <pre>int :game &amp;key title time intro finals chapters start-location start-items</pre>
    <h6>Arguments</h6>
    <p><code>title</code> &ndash; a string, sets game title which will
    be shown before game begins.</p>
    <p><code>time</code> &ndash; an integer, sets initial time (in seconds).</p>
    <p><code>intro</code> &ndash; a string, sets game intro, it will
    be printed as plain text after title.</p>
    <p><code>finals</code> &ndash; one or more strings, allows putting
    one or more variants of final of your game, they will be indexed
    using base <code>0</code> and you will be able to finish game from
    script with desired ending. Note that this parameter may be
    omitted.</p>
    <p><code>chapters</code> &ndash; enumeration where every even
    element is chapter ID (string or integer), and every odd element
    is title of chapter (string or <code>nil</code>).</p>
    <p><code>start-location</code> &ndash; a symbol, specifies ID of
    start room, see information about ID in <a href="#5.1.2.1">section
    5.1.2.1</a>.</p>
    <p><code>start-items</code> items that player will have at the
    beginning, see more information about format of this enumeration
    in the <a href="#5.1.3">section 5.1.3</a>. Note that this
    parameter may be omitted.</p>
    <p> Remember that all keyparameters begin with colon <code>:</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.1.2">5.1.2 Introduce Objects</h4>
    <p> Object is a very basic element in game, all other essences in
    game are derived from it. If you're falimiar with concepts
    of <a href =
    "http://en.wikipedia.org/wiki/Object-oriented_programming">Object
    Oriented Programming</a> (OOP), you can think of object as the
    basic class for everything in MIFE.</p>
    <p> To introduce instance of this type, put
    symbol <code>:object</code> as first parameter of <code>int</code>
    form. Structure of the form is shown below.</p>
    <pre>int :object &amp;key id names description actions actions* pre-action post-action events present</pre>
    <p> OK, there are lots of everything, so let us have separate
    section for every parameter. </p>
    <h5 id="5.1.2.1">5.1.2.1 Concept of ID</h5>
    <p> ID is an internal name of an object. It has to be unique. If
    you supply not unique ID, it will cause an error.</p>
    <p> Whenever you supply ID as a symbol, in its exact form
    (e.g. not in scripts, where it can be variable), you have
    to <a href =
    "http://clhs.lisp.se/Body/s_quote.htm"><code>quote</code></a>
    it. Like this:</p>
    <pre>(quote coin) ; basic way
'coin        ; syntactic sugar</pre>
    <p> ID is a general means to distinguish between objects in
    MIFE. However, a player will never see IDs of objects in game
    (unless he/she uses engine commands to see context of game).</p>
    <p><a href="#top">back to the top</a></p>
    <h5 id="5.1.2.2">5.1.2.2 Names</h5>
    <p> What player will see is a name. You can give as many names for
    an object as you wish. This set of names will be used to recognize
    objects during parsing, as well as for representation of an object
    in sentences. As a result of the design, every name which player
    can use to adress an object, may be used as object's name by the
    engine!</p>
    <p> You can specify names all in one string, or in many
    strings. The following definitions are equal:</p>
    <pre>:id "name0 name1"
:id "name0" "name1"</pre>
    <p> Names may consist of one word or of several words. Latter case
    imposes hyphenation. Consider the following name: </p>
    <pre>"golden-coin"</pre>
    <p> It would appear everyhwere without hyphen, and player might
    use it as <code>golden coin</code>, but for internal
    representation we use hyphenation. This is a long story: in early
    versions of MIFE, all names have to consist of one word. Later,
    grouping of words was invented, and the algorithm began to work
    with muli-word names.</p>
    <p> In MIFE we work with numbers. MIFE recognizes numerals well,
    and there may be several identical items in one location. So we
    have to deal with plural forms of names. In MIFE you can specify
    whether a name has plural form or not. Put asterisk <code>*</code>
    after the last letter of a word and it will be changing its enging
    according to its quantity. Example of a good name:</p>
    <pre>"piece*-of-gold"</pre>
    <p> This name will produce the following variants: </p>
    <pre>piece of gold
pair of pieces of gold
four pieces of gold
half dozen pieces of gold
seven pieces of gold
many pieces of gold</pre>
    <p> Note that MIFE recognises irregular plural forms of nouns as
    well. For example, you could write <code>mouse*</code>, and it
    would produce <code>ten mice</code>.</p>
    <p> You can create a name having no plural form by omitting
    asterisk. It will appear then only in its basic form and numerals
    will be dropped.</p>
    <p> Since version 0.2.0, here is one more useful thing for name
    composition. The technique is called <i>brace expansion</i>. It
    should be familiar for UNIX users, although in MIFE we use
    somewhat simplified variant.</p>
    <p> You can construct string variations concisely by putting
    variable parts into braces. These substrings in braces must be
    separated by commas. No spaces allowed between them. This will
    produce all possible combinations, so that every result string
    will use one of supplied substrings. Since version 0.2.1 nested
    brace expansions are allowed.</p>
    <p> Here are examples:</p>
    <pre>{,green-}{meadow,field} =>
meadow
field
green-meadow
green-filed

{house,home}-of{,-the}-{hunter,huntsman} =>
house-of-hunter
home-of-hunter
house-of-the-hunter
home-of-the-hunter
house-of-huntsman
home-of-huntsman
house-of-the-huntsman
home-of-the-huntsman</pre>
    <p> Remember, that you can use brace expansion
    for <a href="#5.1.2.4">verbs and auxiliary words</a> as well.</p>
    <p><a href="#top">back to the top</a></p>
    <h5 id="5.1.2.3">5.1.2.3 Description</h5>
    <p> Descriptions can consist of any number of strings. After every
    string there may be a script which determines whether this string
    is active or passive. All active strings will be concatenated in
    order to evaluate the actual description. </p>
    <p> This trick allows objects to easily change their
    descriptions. For more information regarding scripting see <a href
   ="#5.3">section 5.3</a>. Note that any non-<code>NIL</code> value
    result of script evaluation will render string as active one.</p>
    <p> Here is example of description that will change as time passes: </p>
    <pre>:description
"It's midnight blue. Sacred silence everywhere."    (script () (time-if :hour 0  5))
"Pale colours of morning are entering the scene."   (script () (time-if :hour 5  11))
"Fresh wind and bright day!"                        (script () (time-if :hour 11 14))
"Hot air of afternoon feels like something static." (script () (time-if :hour 14 22))
"It's getting dark."                                (script () (time-if :hour 22 24))</pre>
    <p> Note that if no script supplied for a string, it will be
    always active.</p>
    <p><a href="#top">back to the top</a></p>
    <h5 id="5.1.2.4">5.1.2.4 Actions</h5>
    <p> Actions define interaction between player and an
    object. Actions must be supplied in form of enumeration, where
    every element begins with a string that contains synonymous verbs
    and ends with a script.</p>
    <p>Here is structure of description of action:</p>
    <table>
      <tr><th>Index</th><th>Type</th><th>Optional</th><th>Meaning</th></tr>
      <tr><td>0</td><td>string</td><td></td><td>Collection of verbs
      associated with action; phrase verbs and multi-word
      constructions are permitted with hyphenation.</td></tr>
      <tr><td>1</td><td>string</td><td>&dagger;</td><td>Auxiliary
      words; phrases and multi-word constructions are permitted with
      hyphenation.</td></tr>
      <tr><td>2</td><td>integer</td><td>&dagger;</td><td>Minmum time
      that action takes, in seconds.</td></tr>
      <tr><td>3</td><td>integer</td><td>&dagger;</td><td>Maximum time
      that action takes, in seconds.</td></tr>
      <tr><td>4</td><td>script</td><td></td><td>Script</td></tr>
    </table>
    <p class="note"> If no integers supplied, duration of action will
    be <code>0</code> seconds. If only one integer supplied duration
    will vary from
    <code>0</code> to the given value.</p>
    <p> Complete example:</p>
    <pre>:actions
;0---------------------| 1-----| 2| 3-| 4----------------------|
"kill eliminate get-rid" "sword" 60 120 (script () (say "boom!")</pre>
    <p> Example of using: </p>
    <pre>>   kill them with my sword!
    boom!
>   _</pre>
    <p > Note that if you specify auxiliary words, script will fire
    only when one of them is used by player. An auxiliary word is only
    recognized after a preposition (except for <code>of</code>, which
    is ignorable). In example above we use <code>with</code>.</p>
    <p> MIFE supports two kinds of actions. All information given
    above is applicable to the both. Actions declared
    with <code>:actions</code> symbol require explicit mentioning of
    their parent object. Actions declared with <code>:actions*</code>
    symbol are <i>generalized</i>. One object can have actions of both
    kinds coexisting together.</p>
    <p> Generalized actions only require matching of verb. Typical
    example might be <code>wait</code> action. Common practice is
    putting all such verbs into one fictive object and introducing it
    into game from very beginning with <code>:present t</code>
    parameter. See <a href="#5.1.2.5">section 5.1.2.5</a> for more
    information about this parameter. Also, generalized actions are
    commonly used for traveling commands.</p>
    <p> Be careful when using generalized actions, their verbs must
    not coincide with normal ones, or you can get a situation when
    both scripts will be executed!</p>
    <p><a href="#top">back to the top</a></p>
    <h5 id="5.1.2.5">5.1.2.5 Events, Context and Presence</h5>
    <p> Events are collection of scripts. You can declare them
    with <code>:events</code> symbol. They always run one by one
    before reading of new player's input, if object is within
    context. Object is usually within context when it is in player's
    inventory, in the same location as player, or when the object is
    introduced with <code>:present t</code> parameter.</p>
    <p> Do not use <code>:present t</code> with anything that may be
    added into context and then removed from it. In particular, do not
    use this parameter with places and items. Proper means of putting
    player into start location and providing him/her with start items
    are described in <a href="#5.1.1">section 5.1.1</a>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.1.3">5.1.3 Introduce Containers</h4>
    <p> Container is an object that has additional
    parameter <code>:contents</code>. Contents are specified as
    enumerations of slots.</p>
    <p> Structure of a slot:</p>
    <table>
      <tr><th>Index</th><th>Type</th><th>Optional</th><th>Meaning</th></tr>
      <tr><td>0</td><td>symbol</td><td></td><td>Object ID. Must be
      quoted.</td></tr>
      <tr><td>1</td><td>integer</td><td>&dagger;</td><td>Quantity. Must
      be a positive integer. If omitted - default value 1 will be
      used.</td></tr>
      <tr><td>2</td><td>string</td><td>&dagger;</td><td>Textual
      description of position. Value <code>&lt;inv&gt;</code> will
      forbid rendering of the object in textual
      descriptions.</td></tr>
    </table>
    <p> Complete example of a slot:</p>
    <pre>:contents
;0--| 1 2------------|
'coin 7 "on the floor"</pre>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.1.4">5.1.4 Introduce Places</h4>
    <p> Place is a sub-type of container. If you want to introduce a
    place, use <code>:place</code> as type specifier because standard
    functions are tuned for this type. (Classes inherited
    from <code>place</code> will also be considered as places by the
    engine.)</p>
    <p> Additionaly, every place can be supplied
    with <code>:location-type</code> parameter. Acceptable values
    are: <code>:in</code>(default), <code>:on</code>
    and <code>:under</code>. This parameter determines pattern that
    will be used for description generation.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.1.5">5.1.5 Introduce Items</h4>
    <p> Items in MIFE are things that player can take with
    him/her. They're objects with additional <code>:possessed</code>
    and <code>:weight</code> parameters. These parameters specify how
    many items of certain kind player currently has and weight of
    everyone of them.</p>
    <p> Do not set these values manually! Proper means of providing
    player with start items are described in <a href =
    "#5.1.1">section 5.1.1</a>.</p>
    <p> To set total weight that player can carry, introduce
    variable <code>max-weight</code> as described
    in <a href="#5.1.6">section 5.1.6.</a></p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.1.6">5.1.6 Introduce Variables</h4>
    <p> Since version 0.3.1, one can introduce global variables. They
    will be saved and restored on saving and loading respectively.</p>
    <h6>Syntax</h6>
    <pre>int :var &amp;rest rest</pre>
    <h6>Arguments</h6>
    <p><code>rest</code> &ndash; a collection of values.</p>
    <h6>Description</h6>
    <p>This form introduces global variables initialized with given
    values. <code>rest</code> must contain even number of elements,
    where elements on even positions (0, 2, ...) are symbols (names of
    variables) and elements on odd positions are values of any type.</p>
    <h6>Example</h6>
    <pre>(int :var
     'max-weight 10
     'my-var0    "string"
     'my-var1    '(1 2 3))</pre>
    <h3 id="5.2">5.2 Creating New Types of Objects</h3>
    <p> Normally you'll want to create your own objects which are
    derived from basic ones.</p>
    <p> Use <code>new</code> form for it, its syntax is shown
    below.</p>
    <h6>Syntax</h6>
    <pre>new class-name base-classes slots</pre>
    <h6>Arguments</h6>
    <p><code>class-name</code> &ndash; a symbol, not evaluated.</p>
    <p><code>base-classes</code> &ndash; list of symbols &ndash; names
    of base classes, not evaluated.</p>
    <p><code>slots</code> &ndash; list of class' slots, not
    evaluated. Every element can be symbol or list, <code>car</code>
    of which is a symbol and <code>cadr</code> is a default value.</p>
    <h6>Description</h6>
    <p><code>new</code> introduces new classes into MIFE.</p>
    <h6>Example</h6>
    <p> Definitions of standard MIFE classes use <code>new</code>
    macro:</p>
    <pre>(new container (object)
     (contents))

(new place (container)
     ((location-type :in)))

(new item (object)
     ((possessed 0)
      (weight    0)))</pre>
    <p><a href="#top">back to the top</a></p>
    <h3 id="5.3">5.3 Scripting</h3>
    <p> Scripting is what gives power to everything in a game. Scripts
    are ananymous (you can't call one script from another) and get
    performed by the engine aumotically. In MIFE we use very simple
    scripting system. In fact, scripts are little blocks of Common
    Lisp code. We have many built-in specific functions that will
    solve trivial problems of IF designing allowing you to concentrate
    on your ideas.</p>
    <p> Here is detailed description of <code>script</code> macro.</p>
    <h6>Syntax</h6>
    <pre>script args &amp;body body</pre>
    <h6>Arguments</h6>
    <p><code>args</code> &ndash; a list, where every element either a
    <a href =
    "http://www.lispworks.com/documentation/lw445/CLHS/Body/t_symbol.htm">symbol</a>
    (not quoted) or list consisting of two symbols.</p>
    <p><code>body</code> &ndash; <a href =
    "http://clhs.lisp.se/Body/26_glo_i.htm#implicit_progn">implicit
    progn</a>.</p>
    <h6>Description</h6>
    <p><code>script</code> provides bindings for symbols given
    in <code>args</code> list. If element of the list was supplied as
    single symbol it will be bound to the value of relevant slot of
    parent instance. If element of <code>args</code> was supplied as a
    list, then <code>car</code> of this list specifies slot,
    while <code>cadr</code> specifies ID of object, slot value of
    which will be bound to symbol. This symbol is result of
    concatenation of three elements: given <code>cadr</code> value,
    character <code>#\-</code> and <code>car</code> value, in said
    order. All such bindings are <i>setfable</i>.</p>
    <p> This table provides information on basic symbols; if you
    create a new type of object, its custom slots will be also
    available.</p>
    <table>
      <tr><th>Symbol</th><th>Type</th><th>Meaning</th></tr>
      <tr><td><code>id</code></td><td>Object</td><td> ID symbol.</td></tr>
      <tr><td><code>name</code></td><td>Object</td><td> Random raw string, one of
      those that you have supplied as name parameter. Asterisk and
      hyphen are preserved. For mentioning normal name use function
      <a href="#5.3.5">use-name</a> with id and quantity.</td></tr>
      <tr><td><code>description</code></td><td>Object</td><td>Ready to use,
      concatenated string.</td></tr>
      <tr><td><code>location-type</code></td><td>Place</td><td>:in, :on or :under</td></tr>
      <tr><td><code>possessed</code></td><td>Item</td><td>Number of items player
      has. Read-only. Use <a href="#5.3.12">create*</a> and <a href
     ="#5.3.13">destroy*</a> functions to give something to player
      or take away something.</td></tr>
      <tr><td><code>n</code></td><td>Object</td><td> Only for use in action
      scripting. Provides number of things player wishes to use. This
      symbol can be bound to integer or symbol :all. Functions
      like <a href="#5.3.16">pick-up</a> will deal with it, in other
      cases you have to check type manually.</td>
    </table>
    <h6>Example</h6>
    <p> See examples for functions described below. </p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.1">5.3.1 Random Numbers: setr &amp; getr</h4>
    <h6>Syntax</h6>
    <pre>setr max
getr</pre>
    <h6>Arguments</h6>
    <p><code>max</code> &ndash; a positive <a href =
   "http://clhs.lisp.se/Body/26_glo_i.htm#integer">integer</a> or a
    positive <a href =
    "http://clhs.lisp.se/Body/26_glo_f.htm#float">float</a>.</p>
    <h6>Description</h6>
    <p><code>setr</code> returns pseudo-random non-negative number
    that is less than <code>max</code> and of the same type
    as <code>max</code>.</p>
    <p><code>getr</code> returns non-negative number, equal to the
    last value returned by <code>setr</code>. If <code>setr</code> has
    not been called at the moment of ivocation
    of <code>getr</code>, <code>NIL</code> will be returned.</p>
    <h6>Example</h6>
    <p> In most cases you can use Common Lisp <a href =
    "http://clhs.lisp.se/Body/f_random.htm"><code>random</code></a>
    function. However, consider this example:</p>
    <pre>:description
"heads" (script () (= 0 (random 2))
"tails" (script () (= 1 (random 2))</pre>
    <p> As you can see, here we're trying to randomly pick only one
    component of a description. This is bugged code: since we use two
    calls of <code>random</code> function, we can get an empty string
    as well as both strings concatenated together.</p>
    <p> Proper realization is using <code>setf</code>
    and <code>getr</code>:</p>
    <pre>:description
"heads" (script () (= 0 (setr 2))
"tails" (script () (= 1 (getr))</pre>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.2">5.3.2 I/O: say & ask</h4>
    <h6>Syntax</h6>
    <pre>say control-string &amp;rest args
ask</pre>
    <h6>Arguments</h6>
    <p><code>control-string</code> &ndash; a string.</p>
    <p><code>args</code> &ndash; control arguments.</p>
    <p><code>promt-prefix</code> &ndash; a stirng.</p>
    <h6>Descriptions</h6>
    <p><code>say</code> prints given <code>control-string</code> after
    applying <code>format</code> function on it
    using <code>args</code> parameters.</p>
    <p><code>ask</code> prints <code>*input-prompt*</code>, then reads
    player's input and returns it as a string as well as boolean value
    which indicates whether player's input have been begun with
    asterisk or not. If the first case took place, asterisk anyway get
    deleted from first returned value. <code>ask</code> is not
    recommended for getting player's input. Try always design your
    games so they use MIFE parser whenever possible.</p>
    <h6>Example</h6>
    <pre>actions:
"count" (script (id possessed) (say "you have ~a!" (use-name id possessed)))</pre>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.3">5.3.3 Work with Time</h4>
    <h6>Syntax</h6>
    <pre>time-get &amp;optional symbol
time-if symbol min &amp;optional max
time-passed symbol x &amp;optional y</pre>
    <h6>Arguments</h6>
    <p><code>symbol</code> &ndash; one of the following: <code>:sec</code>,
    <code>:min</code>, <code>:hour</code>, <code>:date</code>, <code>:month</code>,
    <code>:year</code>, <code>:day</code> or <code>:str</code>.</p>
    <p><code>min</code>, <code>max</code>, <code>x</code>, <code>y</code>
    &ndash; integers.</p>
    <h6>Description</h6>
    <p><code>time-get</code> evaluates actual in-game time or its
    component according to
    supplied <code>symbol</code>. If <code>symbol</code> is not
    supplied, raw time in form of integer (total number of seconds)
    will be returned.</p>
    <p><code>time-if</code> returns non-<code>NIL</code> value if
    component of current in-game time specified by
    supplied <code>symbol</code> (<code>:str</code> is forbidden) is
    greater than or equal to <code>min</code> value and less
    than <code>max</code> value. <code>max</code> value is equal
    to <code>min</code> value, if not supplied. </p>
    <p><code>time-passed</code> evaluates difference between moments
    of time <code>x</code> and <code>y</code> and returns this
    difference in form determined by supplied <code>symbol</code>. If
    argument <code>y</code> is not supplied actual in-game time will
    be used as its value.</p>
    <h6>Examples</h6>
    <pre>(time-get)               ; => 2916
(time-get :str)          ; => "7 hours and 48 minutes, Monday, first day of January"
(time-get :sec)          ; => 36
(time-get :min)          ; => 48
(time-get :hour)         ; => 7
(time-get :date)         ; => 1
(time-get :month)        ; => 1
(time-get :year)         ; => 1900
(time-get :day)          ; => 0
(time-if :hour 1 3)      ; => NIL
(time-if :hour 6 8)      ; => T
(time-passed :hour 1000) ; => 0
(time-passed :min 1000)  ; => 31</pre>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.4">5.3.4 Game Finalization and Chapters</h4>
    <h6>Syntax</h6>
    <pre>game-final &amp;optional index
game-chapter chapter-id</pre>
    <h6>Arguments</h6>
    <p><code>index</code> &ndash; non-negative integer.</p>
    <p><code>chapter-id</code> &ndash; a symbol or an integer.</p>
    <h6>Description</h6>
    <p><code>game-final</code> ends currect game with ending specified
    by <code>index</code>. If index is not supplied, default
    value <code>0</code> will be used. All endings should be defined
    as described in <a href="#5.1.1">section 5.1.1</a>.</p>
    <p><code>game-chapter</code> prints ID and corresponding name of
    chapter, defined with
    form <a href="#5.1.1"><code>int</code></a>.</p>
    <h6>Example</h6>
    <p> See <a href="#4.2">this listing</a>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.5">5.3.5 Creating Context with Output</h4>
    <h6>Syntax</h6>
    <pre>use-name id &amp;optional num</pre>
    <h6>Arguments</h6>
    <p><code>id</code> &ndash; symbol, will be evaluated.</p>
    <p><code>num</code> &ndash; non-negative integer.</p>
    <h6>Description</h6>
    <p><code>use-name</code> returns user-friendly name of object with
    given <code>id</code>. <code>num</code> is used for quantity
    rendering. If <code>num</code> is not supplied, default
    value <code>1</code> will be used.</p>
    <p> This function also parses result string with standard MIFE
    parser, changing internal state of the parser and allowing
    anaphoric references.</p>
    <h6>Example</h6>
    <p> See <a href="#5.3.2">this example</a>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.6">5.3.6 Advanced Output: tell</h4>
    <h6>Syntax</h6>
    <pre>tell what &amp;rest rest</pre>
    <h6>Arguments</h6>
    <p><code>what</code> &ndash; string, keyword or list of keywords,
    will be evaluated.</p>
    <p><code>rest</code> &ndash; lists or symbols.</p>
    <h6>Description</h6>
    <p><code>tell</code> &ndash; prints object <code>what</code> using
    names generated with elements
    of <code>rest</code>. If <code>what</code> is a string, it will be
    processed by <code>format</code> function. If it's a keyword, it
    will be used to find a pattern, provided
    in <code>text/dict.txt</code> file or created with
    function <a href = "#5.3.18"><code>dict-add</code></a>. Thus, one
    can create sections in said file (or in source code) and then use
    templates from those sections in game with <code>tell</code>
    function. If <code>what</code> is a list, then every element is
    expected to be a keyword, which will be used to find relevant
    pattern. The last element of such a list will use strings
    generated with <code>rest</code>, others will be applied one by
    one from right to left. In this case argument for successive
    operation is output of previous one (pipeline).</p>
    <p>If element of <code>rest</code> is a symbol, it determines ID
    of element to render. If element of <code>rest</code> is a
    list, <code>car</code> is ID, <code>cadr</code> is quantity
    (non-negative integer) and <code>caddr</code> is optional string
    which will be appended to result that produced by <a href =
    "#5.3.5"><code>use-name</code></a> function for given ID and
    quantity.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.7">5.3.7 Look Where Player Is: location &amp; player-in</h4>
    <h6>Synax</h6>
    <pre>location
player-in place-id</pre>
    <h6>Arguments</h6>
    <p><code>place-id</code> &ndash; symbol, will be evaluated.</p>
    <h6>Description</h6>
    <p><code>location</code> returns ID of place where player
    currently located.</p>
    <p><code>player-in</code> return non-<code>NIL</code> value if
    player is in location with ID <code>place-id</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.8">5.3.8 Generic Describer: look-around</h4>
    <h6>Syntax</h6>
    <pre>look-around &amp;optional place-id</pre>
    <h6>Arguments</h6>
    <p><code>place-id</code> &ndash; symbol, will be evaluated.</p>
    <h6>Description</h6>
    <p><code>look-around</code> prints description of place with
    ID <code>place-id</code>. If <code>place-id</code> is not
    supplied, default value will be ID of current location.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.9">5.3.9 Traveling</h4>
    <h6>Syntax</h6>
    <pre>travel-to place-id
go-back</pre>
    <h6>Arguments</h6>
    <p><code>place-id</code> &ndash; symbol, will be evaluated.</p>
    <h6>Description</h6>
    <p><code>travel-to</code> will undertake all necessary actions in
    order to relocate player to location with
    ID <code>place-id</code>. This function also invokes <a href =
    "#5.3.8"><code>look-around</code></a> automatically after
    traveling.</p>
    <p><code>go-back</code> calls <code>travel-to</code> passing ID of
    previous location in which player has been before calling of the
    function.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.10">5.3.10 Other Item-Related Predicates</h4>
    <h6>Syntax</h6>
    <pre>player-has item-id &amp;optional quantity
object-in place-id id &amp;optional quantity
player-sees id &amp;optional quantity</pre>
    <h6>Arguments</h6>
    <p><code>id, place-id, item-id</code> &dash; symbols, will be evaluated.</p>
    <p><code>quantity</code> &ndash; non-negative integer.</p>
    <h6>Description</h6>
    <p><code>player-has</code> returns non-<code>NIL</code> value if
    player possesses at least <code>quantity</code> items with
    ID <code>item-id</code>.</p>
    <p><code>object-in</code> &ndash; if at
    least <code>quantity</code> objects with ID <code>id</code> in is
    location with ID <code>place-id</code>, this function will return
    their total number.</p>
    <p><code>player-sees</code> is the same as <code>object-in</code>,
    except for value <code>place-id</code>, which is initialized
    with <a href="#5.3.7"><code>location</code></a>.</p>
    <p> Default value for <code>quantity</code> is <code>1</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.11">5.3.11 Generic Describer: player-inventory</h4>
    <h6>Syntax</h6>
    <pre>player-inventory</pre>
    <h6>Description</h6>
    <p><code>player-inventory</code> prints full description of
    contents of player's inventory.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.12">5.3.12 Creation of Things</h4>
    <h6>Syntax</h6>
    <pre>create place-id &amp;rest rest
create* &amp;rest rest</pre>
    <h6>Arguments</h6>
    <p><code>place-id</code> &ndash; a symbol, will be evaluated.</p>
    <p><code>rest</code> &ndash; enumeration of slots as described in
    <a href="#5.1.3">section 5.1.3</a>.</p>
    <h6>Description</h6>
    <p><code>create</code> creates objects enumerated
    in <code>rest</code> in location with ID <code>place-id</code>.</p>
    <p><code>create*</code> gives player objects enumerated
    in <code>rest</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.13">5.3.13 Destruction of Things</h4>
    <h6>Syntax</h6>
    <pre>destroy place-id &amp;rest rest
destroy* &amp;rest rest</pre>
    <h6>Arguments</h6>
    <p><code>place-id</code> &ndash; a symbol, will be evaluated.</p>
    <p><code>rest</code> &ndash; enumeration of slots as described in
    <a href="#5.1.3">section 5.1.3</a>.</p>
    <h6>Description</h6>
    <p><code>destroy</code> removes objects enumerated
    in <code>rest</code> from location with
    ID <code>place-id</code>.</p>
    <p><code>destroy*</code> takes away from player objects enumerated
    in <code>rest</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.14">5.3.14 Moving Things</h4>
    <h6>Syntax</h6>
    <pre>move from-place to-place &amp;rest rest</pre>
    <h6>Arguments</h6>
    <p><code>from-place, to-place</code> &ndash; symbols.</p>
    <p><code>rest</code> &ndash; enumeration of slots as described in
    <a href="#5.1.3">section 5.1.3</a>.</p>
    <h6>Description</h6>
    <p><code>move</code> moves items enumerated in <code>rest</code>
    from place with ID <code>from-place</code> into place with
    ID <code>to-place</code>. If place <code>place-from</code>
    contains less items than specified, all <i>existing</i> items of
    given ID will be removed, and in place <code>to-place</code>
    all <i>requested</i> items will be created. So if you don't want
    to create objects 'from air', you have to check first.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.15">5.3.15 Change Parameters at Place</h4>
    <h6>Syntax</h6>
    <pre>change-id new-id item-id place-id
change-quantity new-q item-id place-id
change-pos new-pos item-id place-id</pre>
    <h6>Arguments</h6>
    <p><code>new-id, item-id, place-id</code> &ndash; symbols.</p>
    <p><code>new-q</code> &ndash; non-negative integer.</p>
    <p><code>new-pos</code> &ndash; string.</p>
    <h6>Description</h6>
    <p> Said functions change corespoding parameter of slot for
    object with ID <code>item-id</code> in location with
    ID <code>place-id</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.16">5.3.16 Picking Up</h4>
    <h6>Syntax</h6>
    <pre>pick-up item-id &amp;optional n</pre>
    <h6>Arguments</h6>
    <p><code>item-id</code> &ndash; symbol, will be evaluated.</p>
    <p><code>n</code> &ndash; non-negative integer.</p>
    <h6>Description</h6>
    <p><code>pick-up</code> is a generic function for picking up
    items. It tries to pick up <code>n</code> objects with
    ID <code>item-id</code> in current locaiton. All exceptional
    situations are taken care of.</p>
    <p class="note">Note: you can use this function for non-items
    too, it will then print a message that player's action is not
    possible to perform.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.17">5.3.17 Dropping</h4>
    <h6>Syntax</h6>
    <pre>drop item-id &amp;optional n</pre>
    <h6>Arguments</h6>
    <p><code>item-id</code> &ndash; symbol, will be evaluated.</p>
    <p><code>n</code> &ndash; non-negative integer.</p>
    <h6>Description</h6>
    <p><code>drop</code> is a generic function for dropping items. It
    tries to drop <code>n</code> objects with ID <code>item-id</code>
    from player's inventory. All exceptional situations are taken care
    of.</p>
    <p class="note">See note for <a href="#5.3.16">section
    5.3.16</a>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.18">5.3.18 Creating New Dictionary Entries</h4>
    <h6>Syntax</h6>
    <pre>dict-add &amp;rest rest</pre>
    <h6>Arguments</h6>
    <p><code>rest</code> &ndash; a list.</p>
    <h6>Description</h6>
    <p><code>dict-add</code> adds new elements into game
    dictionary. Every even value of <code>rest</code> (0, 2, ...) must
    be a keyword that specifies target section of the dictionary, into
    which words or sentences that placed at odd positions will be
    added. Elements at odd positions may be either lists of strings or
    strings itself.</p>
    <h6>Example</h6>
    <pre>(dict-add :st-my-section0 '("foo" "bar" "baz")
          :st-my-section1 "boom")</pre>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.19">5.3.19 Advanced Scripting Functions</h4>
    <h6>Syntax</h6>
    <pre>get-slot id slot
subcontext predicate
verify-type id type</pre>
    <h6>Arguments</h6>
    <p><code>id, type, slot</code> &ndash; symbols, will be evaluated.</p>
    <p><code>predicate</code> &ndash; a function of one argument.</p>
    <h6>Description</h6>
    <p><code>get-slot</code> returns value of slot <code>slot</code>
    of object with ID <code>id</code>.</p>
    <p><code>subcontext</code> evaluates a list of IDs (symbols) of
    objects which are in context and satisfy
    supplied <code>predicate</code>. You can get full context of the
    game by using <code>(constantly t)</code> as the predicate.</p>
    <p><code>verify-type</code> returns <code>T</code> if object with
    ID <code>id</code> is of type <code>type</code>, otherwise it
    returns <code>NIL</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h4 id="5.3.20">5.3.20 Work with Variables</h4>
    <h6>Syntax</h6>
    <pre>vadd &amp;rest rest
vget name
vset name value</pre>
    <h6>Arguments</h6>
    <p><code>rest</code> &ndash; a collection of values.</p>
    <p><code>name</code> &ndash; symbol.</p>
    <p><code>value</code> &ndash; a value of any type.</p>
    <h6>Description</h6>
    <p><code>vadd</code> creates global variables. <code>rest</code>
    should consist of even number of elements. There should be names
    of variables on even positions (0, 2, ...) and their values on odd
    positions. Effect of function <code>vadd</code> is equal to that
    of method described in <a href="#5.1.6">section 5.1.6</a>.</p>
    <p><code>vget</code> returns value of variable with
    name <code>name</code>.</p>
    <p><code>gset</code> bounds variable with name <code>name</code>
    to value <code>value</code>.</p>
    <p><a href="#top">back to the top</a></p>
    <h3 id="5.4">5.4 Using Common Lumps</h3>
    <h6>Syntax</h6>
    <pre>cmn name &amp;rest rest</pre>
    <h6>Arguments</h6>
    <p><code>name</code> &ndash; a keyword.</p>
    <p><code>rest</code> &ndash; arbitrary sequence of elements.</p>
    <h6>Description</h6>
    <p><code>cmn</code> defines arbitrary sequence of
    elements <code>rest</code> under
    name <code>name</code>. <code>name</code> may be used
    in <code>int</code> form after symbol <code>:+</code>. The
    sequence <code>:+ :foo</code> will be substituted with defined
    sequence before processing of <code>int</code> form.</p>
    <h6>Example</h6>
    <p> <code>cmn</code> form, called 'common lump' is extremely
    useful. A good example of benefits that this form can provide is
    weather implementation. The following code assumes that you have
    defined a new class <code>var</code> with
    field <code>weather</code> and you've implemented algorithm of
    weather changing. In this case you can write:</p>
    <pre>(cmn :weather-description
     "It's raining." (script ((weather var)) (eql var-weather 'rain)))

(int :place
     :id 'my-exterior
     :description
     "A beautiful meadow."
     :+ :weather-description)</pre>
    <p><a href="#top">back to the top</a></p>
  </body>
</html>
